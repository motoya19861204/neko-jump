<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>ねこパイプ — 回転パネルパズル</title>
<style>
  :root{
    --bg:#0f1220;
    --grid:#1b2140;
    --tile:#232a4d;
    --pipe:#9ac1ff;
    --pipeOn:#fff78a;
    --accent:#ff7b6b;
    --panel:#fff;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo,sans-serif;background:radial-gradient(1200px 800px at 70% -10%,#1c2244 0%,#0f1220 60%);}
  #app{max-width:680px;margin:0 auto;padding:16px 16px 28px;}
  header{display:flex;align-items:center;justify-content:space-between;color:#e9eeff;margin-bottom:10px;gap:10px;flex-wrap:wrap}
  h1{font-size:18px;margin:0;font-weight:800;letter-spacing:.02em}
  .stats{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .stat{background:rgba(255,255,255,.06);color:#e9eeff;padding:6px 10px;border-radius:10px;font-weight:700}
  .btn{background:var(--accent);color:#fff;border:none;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer}
  .btn.secondary{background:#3b436d}
  .btn.ghost{background:transparent;border:2px solid #3b436d}
  #boardWrap{background:linear-gradient(180deg,#141938,#0f1220);border-radius:16px;padding:10px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  #board{display:grid;gap:6px;touch-action:manipulation}
  .cell{width:100%;aspect-ratio:1;border-radius:12px;background:var(--tile);position:relative;box-shadow:inset 0 0 0 1px rgba(255,255,255,.04)}
  .cell.win{animation:twinkle .7s ease both}
  @keyframes twinkle{from{box-shadow:0 0 0 0 rgba(255,247,138,.6)}to{box-shadow:0 0 30px 6px rgba(255,247,138,.0)}}
  /* pipes (drawn with pseudo elements) */
  .p{position:absolute;left:0;top:0;right:0;bottom:0;display:block}
  .p::before,.p::after{content:"";position:absolute;background:var(--pipe);transition:background .15s ease}
  .on .p::before,.on .p::after{background:var(--pipeOn)}
  /* connectors (we draw four arms depending on bitmask NESW) */
  .cN::before{left:50%;top:0;transform:translateX(-50%);width:16%;height:42%;}
  .cS::after{left:50%;bottom:0;transform:translateX(-50%);width:16%;height:42%;}
  .cE::before{top:50%;right:0;transform:translateY(-50%);height:16%;width:42%;}
  .cW::after{top:50%;left:0;transform:translateY(-50%);height:16%;width:42%;}
  .core{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:46%;height:46%;border-radius:10px;background:var(--pipe);transition:background .15s ease}
  .on .core{background:var(--pipeOn)}
  /* source / star */
  .src::after{content:"😺";position:absolute;left:50%;top:50%;transform:translate(-50%,-52%);font-size: clamp(16px,4.6vw,26px)}
  .star::after{content:"★";position:absolute;left:50%;top:50%;transform:translate(-50%,-55%);color:#ffd54a;text-shadow:0 2px 0 #b58c00;font-size: clamp(14px,4vw,22px)}
  /* toolbar */
  #toolbar{display:flex;gap:8px;margin:12px 6px 2px;flex-wrap:wrap}
  .note{color:#aab6ff;font-size:12px;opacity:.8}
  /* overlays */
  .overlay{position:fixed;inset:0;background:rgba(4,6,16,.55);display:flex;align-items:center;justify-content:center;padding:16px}
  .panel{background:#fff;border-radius:16px;padding:16px;max-width:540px;width:100%;box-shadow:0 20px 50px rgba(0,0,0,.35)}
  .panel h2{margin:0 0 10px;font-size:20px}
  .levels{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
  .lv{padding:10px;border-radius:10px;border:2px solid #e6e9ff;text-align:center;font-weight:800;cursor:pointer}
  .lv.done{background:#e6ffe6;border-color:#b7f0b7}
  .hidden{display:none}
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>ねこパイプ</h1>
    <div class="stats">
      <div class="stat">レベル <span id="lv">1</span></div>
      <div class="stat">手数 <span id="moves">0</span></div>
      <div class="stat">最短 <span id="best">–</span></div>
      <button class="btn" id="shuffle">リトライ</button>
    </div>
  </header>

  <div id="boardWrap">
    <div id="board"></div>
    <div id="toolbar">
      <button class="btn secondary" id="undo">元に戻す</button>
      <button class="btn ghost" id="hint">ヒント</button>
      <span class="note">タップで右回転／長押しで左回転・右クリックでもOK</span>
    </div>
  </div>
</div>

<!-- level chooser -->
<div id="chooser" class="overlay">
  <div class="panel">
    <h2>レベル選択</h2>
    <p style="margin-top:4px">パイプを回してネコの電源から全ての★に光を届けよう！</p>
    <div id="lvGrid" class="levels" style="margin-top:10px"></div>
  </div>
</div>

<!-- win overlay -->
<div id="win" class="overlay hidden">
  <div class="panel" style="text-align:center">
    <h2>クリア！</h2>
    <div style="margin:6px 0 10px">手数 <b id="finalMoves">0</b>（最短 <b id="finalBest">0</b>）</div>
    <div style="display:flex; gap:8px; justify-content:center">
      <button class="btn" id="next">次のレベル</button>
      <button class="btn secondary" id="replay">もう一度</button>
      <button class="btn ghost" id="choose">レベル選択</button>
    </div>
  </div>
</div>

<script>
/* ========= ゲーム設計 =========
タイルは NESW の接続ビット(1,2,4,8)で表現。
回転でビットを循環。スタート(源)から BFS で通電し、★が全て点灯したらクリア。
レベルに応じてサイズ/★数が増加。シャッフルはランダム回転 + ランダムスワップ少し。
ヒントは源からの最短木の 1 手を示す（プレビュー点滅）。
================================ */

const boardEl = document.getElementById('board');
const movesEl = document.getElementById('moves');
const bestEl  = document.getElementById('best');
const lvEl    = document.getElementById('lv');
const chooser = document.getElementById('chooser');
const winOv   = document.getElementById('win');

const undoBtn = document.getElementById('undo');
const hintBtn = document.getElementById('hint');
const shuffleBtn = document.getElementById('shuffle');
const nextBtn = document.getElementById('next');
const replayBtn = document.getElementById('replay');
const chooseBtn = document.getElementById('choose');

const finalMoves = document.getElementById('finalMoves');
const finalBest  = document.getElementById('finalBest');

const STORAGE = 'neko_pipe_best_v1';

// level config
const levels = Array.from({length:25}, (_,i)=>{
  const idx=i+1;
  const size = Math.min(4+Math.floor(idx/3), 8); // 4→8
  const stars = Math.min(1+Math.floor(idx/4), 4);
  return {id:idx,size,stars};
});

// state
let grid=[], N=5, moves=0, best=null, source=[0,0], stars=[];
let undoStack=[];
let holding=false, holdTimer=null;
let currentLv=1;

// build level grid
function initLevel(lv=currentLv){
  currentLv=lv;
  const conf=levels[lv-1];
  N=conf.size;
  lvEl.textContent=lv;
  boardEl.style.gridTemplateColumns = `repeat(${N}, 1fr)`;

  // generate a spanning tree then add some extra edges
  grid = Array.from({length:N}, ()=>Array.from({length:N}, ()=>({bit:0,on:false,elt:null})));
  function inb(r,c){return r>=0&&c>=0&&r<N&&c<N}
  const dirs = [[-1,0,1],[0,1,2],[1,0,4],[0,-1,8]]; // [dr,dc,bit]
  // carve tree with DFS
  const seen=new Set();
  function carve(r,c){
    seen.add(r+','+c);
    const order = dirs.slice().sort(()=>Math.random()-0.5);
    for(const [dr,dc,bit] of order){
      const nr=r+dr,nc=c+dc, opp = (bit===1?4:bit===2?8:bit===4?1:2);
      if(!inb(nr,nc) || seen.has(nr+','+nc)) continue;
      grid[r][c].bit |= bit; grid[nr][nc].bit |= opp;
      carve(nr,nc);
    }
  }
  const sr = Math.floor(Math.random()*N), sc = Math.floor(Math.random()*N);
  source=[sr,sc];
  carve(sr,sc);

  // add a few random cycles
  for(let k=0;k<N;k++){
    const r=Math.floor(Math.random()*N), c=Math.floor(Math.random()*N);
    const pick = dirs[Math.floor(Math.random()*4)];
    const [dr,dc,bit] = pick, nr=r+dr, nc=c+dc, opp=(bit===1?4:bit===2?8:bit===4?1:2);
    if(inb(nr,nc)){ grid[r][c].bit|=bit; grid[nr][nc].bit|=opp; }
  }

  // place stars on far nodes
  const far = farthestNodesFrom(source[0],source[1], grid);
  stars = far.slice(0, conf.stars);

  // shuffle rotations (guarantee solvable by rotation only)
  for(let r=0;r<N;r++)for(let c=0;c<N;c++){
    const rot = Math.floor(Math.random()*4);
    grid[r][c].bit = rotBits(grid[r][c].bit, rot);
  }

  // build DOM
  boardEl.innerHTML='';
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const cell=document.createElement('div');
      cell.className='cell';
      cell.dataset.r=r; cell.dataset.c=c;
      const p = document.createElement('div'); p.className='p';
      const core = document.createElement('div'); core.className='core';
      cell.appendChild(p); cell.appendChild(core);
      boardEl.appendChild(cell);
      grid[r][c].elt=cell;
    }
  }

  // mark source & stars
  getCell(source).classList.add('src');
  for(const s of stars) getCell(s).classList.add('star');

  moves=0; movesEl.textContent='0'; undoStack.length=0;
  best = loadBest(lv) ?? null; bestEl.textContent = best??'–';

  layoutPipes();
  propagate();
  chooser.classList.add('hidden');
  winOv.classList.add('hidden');
}

function getCell([r,c]){ return grid[r][c].elt; }

function rotBits(bits,k){ // rotate k times CW
  k%=4; if(k<0)k+=4;
  for(let i=0;i<k;i++){
    const n = (bits&1)?2:0;
    const e = (bits&2)?4:0;
    const s = (bits&4)?8:0;
    const w = (bits&8)?1:0;
    bits = n|e|s|w;
  }
  return bits;
}

function layoutPipes(){
  for(let r=0;r<N;r++)for(let c=0;c<N;c++){
    const cell=grid[r][c].elt, bit=grid[r][c].bit;
    const p=cell.querySelector('.p'), core=cell.querySelector('.core');
    p.className='p'; // reset
    core.className='core';
    // add connectors as classes for CSS arms
    if(bit&1) p.classList.add('cN');
    if(bit&2) p.classList.add('cE');
    if(bit&4) p.classList.add('cS');
    if(bit&8) p.classList.add('cW');
  }
}

function propagate(){
  // BFS from source via matching connectors
  for(let r=0;r<N;r++)for(let c=0;c<N;c++) grid[r][c].on=false;
  const q=[[...source]], seen=new Set([source.join()]);
  function has(r,c,bit){return (grid[r][c].bit & bit) !== 0}
  while(q.length){
    const [r,c]=q.shift();
    grid[r][c].on=true;
    const neigh = [
      [r-1,c,1,4],[r,c+1,2,8],[r+1,c,4,1],[r,c-1,8,2]
    ];
    for(const [nr,nc,need,back] of neigh){
      if(nr<0||nc<0||nr>=N||nc>=N) continue;
      if(!has(r,c,need) || !has(nr,nc,back)) continue;
      const key=nr+','+nc; if(seen.has(key)) continue;
      seen.add(key); q.push([nr,nc]);
    }
  }
  // paint
  for(let r=0;r<N;r++)for(let c=0;c<N;c++){
    const cell=grid[r][c].elt;
    cell.classList.toggle('on', grid[r][c].on);
  }
  // check win
  const allOn = stars.every(([r,c])=>grid[r][c].on);
  if(allOn){
    for(const s of stars) getCell(s).classList.add('win');
    setTimeout(()=>win(), 140);
  }
}

function win(){
  finalMoves.textContent = moves;
  const prev = loadBest(currentLv);
  if(prev==null || moves<prev){ saveBest(currentLv, moves); bestEl.textContent=moves; }
  finalBest.textContent = loadBest(currentLv);
  winOv.classList.remove('hidden');
  // mark chooser tile as done later
}

function saveBest(lv,val){
  const obj = JSON.parse(localStorage.getItem(STORAGE)||'{}');
  obj[lv]=val; localStorage.setItem(STORAGE, JSON.stringify(obj));
}
function loadBest(lv){
  const obj = JSON.parse(localStorage.getItem(STORAGE)||'{}'); return obj[lv] ?? null;
}

/* interactions */
boardEl.addEventListener('contextmenu', e=>e.preventDefault());

boardEl.addEventListener('pointerdown', e=>{
  const cell = e.target.closest('.cell'); if(!cell) return;
  const r=+cell.dataset.r, c=+cell.dataset.c;
  rotateCell(r,c,+1); // default CW
  // long-press to rotate CCW
  holding=true;
  holdTimer = setTimeout(()=>{ if(holding){ rotateCell(r,c,-1); } }, 400);
});

boardEl.addEventListener('pointerup', ()=>{ holding=false; clearTimeout(holdTimer); });
boardEl.addEventListener('pointerleave', ()=>{ holding=false; clearTimeout(holdTimer); });

boardEl.addEventListener('contextmenu', e=>{
  const cell = e.target.closest('.cell'); if(!cell) return;
  const r=+cell.dataset.r, c=+cell.dataset.c;
  rotateCell(r,c,-1);
  e.preventDefault();
});

function rotateCell(r,c,dir){
  undoStack.push({r,c,prev:grid[r][c].bit});
  grid[r][c].bit = rotBits(grid[r][c].bit, dir>0?1:3);
  moves++; movesEl.textContent = moves;
  layoutPipes(); propagate();
}

undoBtn.addEventListener('click', ()=>{
  const last = undoStack.pop(); if(!last) return;
  grid[last.r][last.c].bit = last.prev;
  moves++; movesEl.textContent=moves; // ペナルティとして+1
  layoutPipes(); propagate();
});

shuffleBtn.addEventListener('click', ()=> initLevel(currentLv));

hintBtn.addEventListener('click', ()=>{
  // simple hint: find neighbor of source component that mismatches and suggest rotation
  const comp = new Set();
  const q=[[...source]]; comp.add(source.join());
  function has(r,c,b){return (grid[r][c].bit & b)!==0}
  while(q.length){
    const [r,c]=q.shift();
    const neigh = [[r-1,c,1,4],[r,c+1,2,8],[r+1,c,4,1],[r,c-1,8,2]];
    for(const [nr,nc,need,back] of neigh){
      if(nr<0||nc<0||nr>=N||nc>=N) continue;
      if(has(r,c,need) && has(nr,nc,back)){
        const key=nr+','+nc; if(!comp.has(key)){comp.add(key);q.push([nr,nc]);}
      }
    }
  }
  // pick star not lit and find a tile along path towards it (greedy)
  const target = stars.find(([r,c])=>!grid[r][c].on); if(!target) return;
  // highlight its neighbors
  const [tr,tc]=target;
  const around=[[tr-1,tc],[tr,tc+1],[tr+1,tc],[tr,tc-1]].filter(([r,c])=>r>=0&&c>=0&&r<N&&c<N);
  let candidate=null;
  for(const [r,c] of around){
    if(comp.has(r+','+c)){ candidate=[tr,tc]; break; }
  }
  if(!candidate) candidate = [tr,tc];
  // flash candidate
  const el = getCell(candidate);
  el.style.outline='3px solid #fff78a';
  setTimeout(()=>{el.style.outline='';}, 700);
});

/* chooser grid */
(function buildChooser(){
  const grid=document.getElementById('lvGrid');
  levels.forEach(l=>{
    const b=document.createElement('button');
    b.className='lv';
    b.textContent=l.id;
    const best = loadBest(l.id); if(best!=null) b.classList.add('done');
    b.onclick=()=>{ initLevel(l.id); chooser.classList.add('hidden'); };
    grid.appendChild(b);
  });
})();

nextBtn.addEventListener('click', ()=>{
  const nxt = Math.min(levels.length, currentLv+1);
  initLevel(nxt);
});
replayBtn.addEventListener('click', ()=> initLevel(currentLv));
chooseBtn.addEventListener('click', ()=>{
  winOv.classList.add('hidden'); chooser.classList.remove('hidden');
});

/* first time */
initLevel(1);
chooser.classList.remove('hidden');

/* responsive sizing */
function resizeBoard(){
  const w = Math.min(680, window.innerWidth-24);
  const gap = 6*(N-1)+20; // padding-ish
  const cell = Math.floor((w-gap)/N);
  const size = Math.max(52, Math.min(110, cell));
  boardEl.style.setProperty('--cell', size+'px');
  // actually width comes from grid, so just rely on aspect ratio
}
window.addEventListener('resize', resizeBoard);
resizeBoard();

/* ========= 便利関数 ========= */
function farthestNodesFrom(sr,sc, grid){
  // BFS distances, pick far nodes (sorted)
  const N=grid.length; const d=Array.from({length:N},()=>Array(N).fill(Infinity));
  const q=[[sr,sc]]; d[sr][sc]=0;
  while(q.length){
    const [r,c]=q.shift();
    const neigh = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
    for(const [nr,nc] of neigh){
      if(nr<0||nc<0||nr>=N||nc>=N||d[nr][nc]!==Infinity) continue;
      d[nr][nc]=d[r][c]+1; q.push([nr,nc]);
    }
  }
  const arr=[];
  for(let r=0;r<N;r++)for(let c=0;c<N;c++) if(!(r===sr&&c===sc)) arr.push([r,c,d[r][c]]);
  arr.sort((a,b)=>b[2]-a[2]);
  return arr.map(x=>[x[0],x[1]]);
}
</script>
</body>
</html>